name: Release Helm Chart with Cosign (OCI)

on:
  workflow_dispatch:
  release:
    types: [published]

jobs:
  release-chart:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write
    env:
      GPG_NAME: "1moses1"
      GPG_EMAIL: "iradukundam47@gmail.com"
      CHART_DIR: "backstage-helm-chart"
      YQ_VERSION: "v4.40.5" # Specify a recent stable version of Mike Farah's yq

    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Configure Git Identity
        run: |
          git config user.name "${{ env.GPG_NAME }}"
          git config user.email "${{ env.GPG_EMAIL }}"

      - name: Set up Helm
        uses: azure/setup-helm@v4.3.0
        with:
          version: v3.14.3

      - name: Install dependencies (jq, gnupg, curl, oras, Mike Farah's yq, pinentry)
        run: |
          sudo apt-get update -y
          # Ensure pinentry-curses is installed (common non-interactive pinentry)
          sudo apt-get install -y jq gnupg2 curl coreutils pinentry-curses
          
          echo "Installing yq ${{ env.YQ_VERSION }}..."
          sudo wget https://github.com/mikefarah/yq/releases/download/${{ env.YQ_VERSION }}/yq_linux_amd64 -O /usr/local/bin/yq
          sudo chmod +x /usr/local/bin/yq
          echo "yq version: $(yq --version)" # Verify installed yq version

          ORAS_VERSION="1.1.0" # Specify desired ORAS version
          curl -LO "https://github.com/oras-project/oras/releases/download/v${ORAS_VERSION}/oras_${ORAS_VERSION}_linux_amd64.tar.gz"
          tar -zxvf "oras_${ORAS_VERSION}_linux_amd64.tar.gz"
          sudo mv oras /usr/local/bin/oras
          echo "oras version: $(oras version)"

      - name: Set up Cosign
        uses: sigstore/cosign-installer@v3.5.0

      - name: Authenticate to GHCR (Helm + Docker)
        run: |
          echo "${{ secrets.GHCR_TOKEN }}" | helm registry login ghcr.io -u ${{ github.actor }} --password-stdin
          echo "${{ secrets.GHCR_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Update Chart Version from Tag
        run: |
          VERSION=${GITHUB_REF#refs/tags/}
          yq eval ".version = \"$VERSION\"" -i "$CHART_DIR/Chart.yaml"
          echo "Updated Chart.yaml version to $VERSION"
          echo "Contents of $CHART_DIR/Chart.yaml after update:"
          cat "$CHART_DIR/Chart.yaml"

      - name: Auto-generate GPG Key and Prepare Environment
        id: gpg_setup
        run: |
          # Use the default GPG home directory for better compatibility
          export GNUPGHOME="$HOME/.gnupg"
          mkdir -p "$GNUPGHOME"
          chmod 700 "$GNUPGHOME"
          echo "GNUPGHOME_PATH=$GNUPGHOME" >> $GITHUB_OUTPUT
          echo "Using GNUPGHOME for setup: $GNUPGHOME"
          
          # Configure GPG for non-interactive use
          cat > "$GNUPGHOME/gpg.conf" << EOF
          use-agent
          pinentry-mode loopback
          batch
          yes
EOF
          
          cat > "$GNUPGHOME/gpg-agent.conf" << EOF
          allow-loopback-pinentry
          pinentry-program /usr/bin/pinentry-curses
EOF

          echo "Starting gpg-agent with explicit configuration..."
          gpg-agent --daemon --pinentry-program /usr/bin/pinentry-curses --allow-loopback-pinentry
          
          echo "Generating GPG key..."
          cat > /tmp/gpg-key-script << EOF
          Key-Type: RSA
          Key-Length: 2048
          Subkey-Type: RSA
          Subkey-Length: 2048
          Name-Real: ${{ env.GPG_NAME }}
          Name-Email: ${{ env.GPG_EMAIL }}
          Expire-Date: 1d
          Passphrase: 
          %commit
EOF
          
          gpg --batch --gen-key /tmp/gpg-key-script
          
          GPG_FINGERPRINT=$(gpg --list-secret-keys --with-colons "${{ env.GPG_EMAIL }}" | grep '^fpr:' | cut -d':' -f10)
          if [ -z "$GPG_FINGERPRINT" ]; then
            echo "Error: Could not retrieve GPG Key Fingerprint." >&2
            gpg --list-secret-keys --with-colons "${{ env.GPG_EMAIL }}"
            exit 1
          fi
          echo "GPG_FINGERPRINT_VALUE=$GPG_FINGERPRINT" >> $GITHUB_OUTPUT
          echo "Generated GPG Key Fingerprint: $GPG_FINGERPRINT"

          # Export keys in multiple formats for maximum compatibility
          echo "Exporting keys in various formats..."
          gpg --batch --yes --export -o "$GNUPGHOME/pubring.gpg"
          gpg --batch --yes --export-secret-keys -o "$GNUPGHOME/secring.gpg"
          gpg --batch --yes --armor --export-secret-keys "$GPG_FINGERPRINT" > "$GNUPGHOME/private-key.asc"
          gpg --batch --yes --export-secret-keys "$GPG_FINGERPRINT" > "$GNUPGHOME/private.key"
          
          # Also export to a location Helm might look for
          mkdir -p ~/.gnupg
          cp "$GNUPGHOME/secring.gpg" ~/.gnupg/secring.gpg 2>/dev/null || true
          cp "$GNUPGHOME/pubring.gpg" ~/.gnupg/pubring.gpg 2>/dev/null || true
          
          echo "Verifying key files..."
          for file in pubring.gpg secring.gpg private-key.asc private.key; do
            if [ -f "$GNUPGHOME/$file" ] && [ -s "$GNUPGHOME/$file" ]; then
              echo "$GNUPGHOME/$file exists and is not empty."
              ls -l "$GNUPGHOME/$file"
            else
              echo "Warning: $GNUPGHOME/$file was NOT created or is empty!" >&2
            fi
          done
          
          echo "Listing GPG keys:"
          gpg --list-keys
          gpg --list-secret-keys
          
          echo "Testing GPG signing capability..."
          echo "Test content for signing" > test_file.txt
          if gpg --batch --yes --pinentry-mode loopback --passphrase '' --local-user "$GPG_FINGERPRINT" --detach-sign test_file.txt; then
            echo "GPG signing test successful!"
            ls -l test_file.txt*
          else
            echo "Warning: GPG signing test failed!" >&2
          fi

      - name: Package chart with provenance
        env:
          GNUPGHOME: ${{ steps.gpg_setup.outputs.GNUPGHOME_PATH }}
          GPG_KEY_ID_FOR_HELM: ${{ steps.gpg_setup.outputs.GPG_FINGERPRINT_VALUE }}
        run: |
          echo "Preparing environment for Helm package step..."
          echo "GNUPGHOME for Helm: $GNUPGHOME"
          echo "GPG_KEY_ID for Helm: $GPG_KEY_ID_FOR_HELM"
          
          # Ensure GPG agent is running and properly configured
          export GPG_TTY=/dev/console
          echo "GPG_TTY set to: $GPG_TTY"
          
          # Restart gpg-agent to ensure it's available for Helm
          gpgconf --kill gpg-agent
          gpg-agent --daemon --pinentry-program /usr/bin/pinentry-curses --allow-loopback-pinentry
          
          echo "Verifying GPG setup before packaging..."
          gpg --list-secret-keys
          
          # Test GPG functionality one more time
          echo "Testing GPG signing before Helm packaging..."
          echo "test" | gpg --batch --yes --pinentry-mode loopback --passphrase '' --clearsign --local-user "$GPG_KEY_ID_FOR_HELM"
          
          echo "Checking for required keyring files..."
          for file in pubring.gpg secring.gpg private-key.asc private.key; do
            if [ -f "$GNUPGHOME/$file" ]; then
              echo "✓ $GNUPGHOME/$file exists ($(ls -lh "$GNUPGHOME/$file" | awk '{print $5}'))"
            else
              echo "✗ $GNUPGHOME/$file missing"
            fi
          done

          echo "Attempting Helm package with signing..."
          
          # Try multiple approaches in order of likelihood to succeed
          SUCCESS=false
          
          # Method 1: Use default GPG setup (most likely to work)
          echo "=== Method 1: Default GPG environment ==="
          if helm package "$CHART_DIR" --sign --key "$GPG_KEY_ID_FOR_HELM" --debug; then
            echo "✓ Method 1 succeeded!"
            SUCCESS=true
          else
            echo "✗ Method 1 failed"
            
            # Method 2: Explicitly specify keyring location
            echo "=== Method 2: Explicit keyring specification ==="
            if helm package "$CHART_DIR" --sign --key "$GPG_KEY_ID_FOR_HELM" --keyring "$GNUPGHOME/secring.gpg" --debug; then
              echo "✓ Method 2 succeeded!"
              SUCCESS=true
            else
              echo "✗ Method 2 failed"
              
              # Method 3: Use short key ID instead of full fingerprint
              echo "=== Method 3: Short key ID ==="
              SHORT_KEY_ID=${GPG_KEY_ID_FOR_HELM: -8}
              echo "Using short key ID: $SHORT_KEY_ID"
              if helm package "$CHART_DIR" --sign --key "$SHORT_KEY_ID" --debug; then
                echo "✓ Method 3 succeeded!"
                SUCCESS=true
              else
                echo "✗ Method 3 failed"
                
                # Method 4: Try with email as key identifier
                echo "=== Method 4: Using email as key identifier ==="
                if helm package "$CHART_DIR" --sign --key "${{ env.GPG_EMAIL }}" --debug; then
                  echo "✓ Method 4 succeeded!"
                  SUCCESS=true
                else
                  echo "✗ Method 4 failed"
                  
                  # Method 5: Last resort - package without signing
                  echo "=== Method 5: Package without signing (fallback) ==="
                  echo "WARNING: Falling back to unsigned package due to GPG signing issues"
                  if helm package "$CHART_DIR" --debug; then
                    echo "✓ Method 5 succeeded (unsigned package created)"
                    SUCCESS=true
                  else
                    echo "✗ All methods failed"
                  fi
                fi
              fi
            fi
          fi
          
          if [ "$SUCCESS" = false ]; then
            echo "ERROR: All packaging methods failed"
            exit 1
          fi
          
          echo "Checking generated package files..."
          ls -la *.tgz *.prov 2>/dev/null || echo "No .tgz or .prov files found"

      - name: Push chart to OCI
        run: |
          CHART_PACKAGE_FILE=$(ls *.tgz | head -n 1)
          if [ -z "$CHART_PACKAGE_FILE" ]; then
            echo "Error: No .tgz chart package found to push." >&2
            exit 1
          fi
          echo "Pushing chart package: $CHART_PACKAGE_FILE"
          helm push "$CHART_PACKAGE_FILE" "oci://ghcr.io/${{ github.repository_owner }}/charts"

      - name: Get chart digest
        id: digest
        run: |
          CHART_NAME_LOWER=$(echo "${{ env.CHART_DIR }}" | tr '[:upper:]' '[:lower:]')
          VERSION=${GITHUB_REF#refs/tags/}
          OCI_CHART_REF_BASE="ghcr.io/${{ github.repository_owner }}/charts/${CHART_NAME_LOWER}"
          
          echo "Fetching manifest digest for: ${OCI_CHART_REF_BASE}:${VERSION}"
          # Ensure oras is authenticated if needed, though docker login might cover it for GHCR
          MANIFEST_DIGEST=$(oras manifest fetch --descriptor "${OCI_CHART_REF_BASE}:${VERSION}" | jq -r '.digest')
          if [ -z "$MANIFEST_DIGEST" ] || [ "$MANIFEST_DIGEST" == "null" ]; then
            echo "Warning: Could not retrieve manifest digest directly. Trying fallback by pushing temp tag..." >&2
            TEMP_TAG="temp-digest-$(date +%s)-${RANDOM}"
            oras manifest push "${OCI_CHART_REF_BASE}:${TEMP_TAG}" "${OCI_CHART_REF_BASE}:${VERSION}"
            MANIFEST_DIGEST=$(oras manifest fetch --descriptor "${OCI_CHART_REF_BASE}:${TEMP_TAG}" | jq -r '.digest')
            oras manifest delete "${OCI_CHART_REF_BASE}:${TEMP_TAG}" # Clean up
          fi
          if [ -z "$MANIFEST_DIGEST" ] || [ "$MANIFEST_DIGEST" == "null" ]; then
            echo "Error: Still could not retrieve a valid manifest digest." >&2
            exit 1
          fi
          echo "MANIFEST_DIGEST_VALUE=$MANIFEST_DIGEST" >> $GITHUB_OUTPUT
          echo "Using Manifest Digest for Cosign: $MANIFEST_DIGEST"

      - name: Sign chart with Cosign (digest)
        run: |
          CHART_NAME_LOWER=$(echo "${{ env.CHART_DIR }}" | tr '[:upper:]' '[:lower:]')
          CHART_OCI_REF_WITH_DIGEST="ghcr.io/${{ github.repository_owner }}/charts/${CHART_NAME_LOWER}@${{ steps.digest.outputs.MANIFEST_DIGEST_VALUE }}"
          echo "Signing OCI chart with Cosign: $CHART_OCI_REF_WITH_DIGEST"
          # Enable experimental features for Cosign if needed for OCI image signing
          export COSIGN_EXPERIMENTAL=1 
          cosign sign --yes "$CHART_OCI_REF_WITH_DIGEST"
          echo "Cosign signing complete. Verifying signatures (optional)..."
          # Verification might require specific public keys or identity providers configured
          # cosign verify "$CHART_OCI_REF_WITH_DIGEST"
